# 5장

생성일: 2024년 9월 17일 오후 12:44

4장에서는 객체지향 언어의 특징을 배웠으니 그 특징을 사용해서 객체지향 소프트웨어를 설계하기 위한 방법이나 원칙을 배운다. 이 원칙들은 모두 응집도는 높이고 (High Cohesion) 결합도는 낮추기 위한 (Loose Coupling) 고전 원칙을 객체지향 관점에서 재정립 한 것이라고 볼 수 있다.

여기서 결합도는 모듈(클래스)간의 상호 의존 정도로서 결합도가 낮으면 모듈 간 상호 의존성이 줄어서 객채의 재사용이나 수정, 유지보수가 용이하다.

응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 재사용이나 수정, 유지보수가 용이하다.

SOLID는 개념이기 때문에 사람의 관점에 따라 다르게 해석될 수 있으며, 적용이 됐는지 애매모호 하기도 하다. 하지만, SOLID는 소프트웨어에 녹여 내야 하는 개념이기 때문에 이해하기 쉽고, 유지보수하기에 쉽고 논리적이다. 

# SRP(Single Responsibility Principle): 단일 책임 원칙

<aside>
💡

어떤 클래스를 변경하는 이유는 오직 하나뿐이어야 한다.

</aside>

특정 클래스가 엄청나게 많은 역할과 책임을 수행하게 되면 이는 나쁜 냄새가 난다. 따라서 이를 클래스의 상속, 또는 인터페이스를 통해서 역할과 책임을 분리하는 것이 단일 책임 원칙이다. 좌측의 객체를 우측의 객체로 역할과 책임을 분리시켜 준 것이다.

![image.png](5%E1%84%8C%E1%85%A1%E1%86%BC%201044e3362f1e80f6903ffcb0539875d0/image.png)

![image.png](5%E1%84%8C%E1%85%A1%E1%86%BC%201044e3362f1e80f6903ffcb0539875d0/image%201.png)

단일 책임 원칙은 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에 모두 적용이 가능하다.

# OCP(Open Closed Principle): 개방 폐쇄 원칙

<aside>
💡

Should be open for Extension, But closed for modification

자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다.

</aside>

특정 운전자가 수동 운전을 하는 포터를 가지고 운전하다가 어느날 쏘나타를 구매했다. 그러면 포터에서는 사용했던 기어 수동 조작() 메소드를 사용하지 못한다. 쏘나타로 차종을 바꾸자 기어 자동 조작() 메소드를 사용하게 되었다. 즉 스틱 차량에서 오토 차량으로 바꿨다고 해서 운전자가 영향을 받아야할까?

이 때는 상위클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않게 된다. 다양한 자동차가 생기는 것은 자동차 입장에서는 확장에 개방되어 있느 것이고, 운전자 입장에서는 주변의 변화에 닫혀있는 것이다. 

# LSP(Liskov Substitution Principle): 리스코프 치환 원칙

<aside>
💡

서브 타입은 언제나 자신의 base type으로 교체할 수 있어야 한다.

</aside>

아버지를 상위 클래스(기반 타입 base type)으로 하는 딸이라는 하위 클래스가 있다고 하자. 그러면 상위 클래스의 객체 참조 변수에는 하위 클래스의 인스턴스를 할당할 수 있다.

`아버지 춘향이 = new 딸()`

딸을 만들어서 춘향이라고 한 것까지는 좋은데 아빠의 역할을 하고있다. 즉, 춘향이는 아버지형 객체 참조 변수이기 때문에 아버지 객체가 가진 행동을 할 수 있어야 한다. 하지만 여기에서는 이상해 보인다.

따라서 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.

# ISP(Interface Segregation Prniciple): 인터페이스 분리 원칙

<aside>
💡

클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.

</aside>

한 클래스가 여러 개의 역할을 가지고 있다고 해보자. 여기서 이전의 단일 책임 원칙에서는 남자 클래스를 분리시켜서 하나의 역할(책임)만 하는 다수의 클래스로 분할시켰으나, ISP 에서는 인터페이스를 분할시켜서 역할을 분리 시키는 것이 ISP이다. 

하지만 특별한 경우가 아니라면 단일 책임 원칙을 사용하는 것이 더 좋다고 볼 수 있다. 인터페이스 최소주의 원칙이라는 것이 있는데, 인터페이스는 그 역할에 충실한 최소한의 기능만 공개하는 것이 정론이다. 인터페이스는 is able to 라는 기준으로 만드는 것이 정석이다.

즉, 각 클라이언트가 자신이 필요한 인터페이스만 의존하게 하는 것이다. 이렇게 하면 클라이언트는 자신이 실제로 사용하지 않는 메서드에 영향을 받지 않게 되고, 변경에 대한 영향을 최소화할 수 있다.

# DIP(Dependency Inversion Principle): 의존 역전 원칙

<aside>
💡

고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.

추상화 된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.

자주 변경되는 구체(Concreate) 클래스에 의존하지 마라

</aside>

자동타는 한국타이어에 의존적이다. 그러네 자동차는 한 번 사면 몇 년 타야하는데 스노우 타이어는 다른 타이어로 교체해야한다. 이런 경우 자동차는 타이어를 교체할 시 영향에 노출돼있다. 자주 자주 변하는 타이어에 의존하기 때문에 나쁜 냄새를 풍긴다.

이 문제를 해결하기 위해서는 자동차가 구체적인 특정 타이어가 아니라 추상화된 타이어 인터페이스에만 의존하게 함으로써 한국 타이어에서 일반 타이어로, 또는 다른 구체적인 타이어로 변경돼도 자동차는 영향을 받지 않는 형태로 구성한다.

즉 이는 의존의 방향이 역전된 것이다. 자동차는 변하기 쉬운 한국타이어에 의존하던 관계를 중간에 추상화된 인터페이스를 추가해두고 의존 관계를 역전시켰다. 

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어서 변하기 쉬운 것의 변화에 영향을 받지 않게 하는 것이 DIP이다.

# SOLID의 정리

SoC는 관심사의 분리 (Separation Of Concerns)의 머리 글자이다. 관심이 같은 것 끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하는 것이다. 

SRP: 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

OCP: 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.

LSP: 서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.

ISP: 클라이언트는 자신이 사용하지 않는 메소드에 의존관계를 맺으면 안 된다.

DIP: 자신보다 변하기 쉬운 것에 의존하지 마라.